<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>IQ大戦（MVP）- ガチIQ問題そのまま対戦</title>
<style>
  :root{
    --bg0:#07090c;
    --bg1:#0b0f14;
    --text:#e9eef6;
    --muted: rgba(233,238,246,0.66);

    --stroke-weak: rgba(255,255,255,0.14);
    --stroke-strong: rgba(255,255,255,0.22);

    --good: rgba(52,243,160,0.42);
    --bad: rgba(255,77,109,0.42);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:
      radial-gradient(1200px 600px at 20% 0%, rgba(52,243,160,0.10), transparent 60%),
      radial-gradient(900px 600px at 90% 20%, rgba(52,243,160,0.06), transparent 65%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
  .wrap{ max-width: 900px; margin: 0 auto; padding: 18px 14px 26px; }
  .topbar{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; margin-bottom: 12px; }
  h1{ margin:0; font-size: 18px; letter-spacing: .08em; font-weight: 900; }
  .pill{
    padding:8px 10px;
    border:1px solid var(--stroke-strong);
    background: rgba(255,255,255,0.04);
    border-radius: 12px;
    font-size: 12px;
    color: var(--muted);
    white-space:nowrap;
    height: fit-content;
  }

  /* ===== ルール色分け：card枠 ===== */
  .card{
    --ruleGlow: rgba(52,243,160,0.22);
    --ruleStroke: rgba(52,243,160,0.40);
    border: 2px solid var(--ruleStroke);
    background: rgba(255,255,255,0.045);
    border-radius: 16px;
    padding: 14px;
    box-shadow:
      0 10px 30px rgba(0,0,0,0.38),
      0 0 0 1px var(--ruleGlow) inset,
      0 0 34px var(--ruleGlow);
    backdrop-filter: blur(6px);
  }
  .rule-xorxor, .rule-xoror, .rule-orxor, .rule-xorand, .rule-andxor, .rule-xorxnor, .rule-xnorxor{
    --ruleGlow: rgba(52,243,160,0.22);
    --ruleStroke: rgba(52,243,160,0.46);
  }
  .rule-orand, .rule-andor, .rule-oror{
    --ruleGlow: rgba(120,170,255,0.22);
    --ruleStroke: rgba(120,170,255,0.48);
  }
  .rule-andand, .rule-andxnor, .rule-xnorand, .rule-xnorxnor{
    --ruleGlow: rgba(200,120,255,0.22);
    --ruleStroke: rgba(200,120,255,0.50);
  }
  .rule-notnot, .rule-notxor, .rule-xornot, .rule-notor, .rule-ornot, .rule-notand, .rule-andnot, .rule-notxnor, .rule-xnornot{
    --ruleGlow: rgba(255,90,120,0.20);
    --ruleStroke: rgba(255,90,120,0.46);
  }
  .rule-rot2{
    --ruleGlow: rgba(255,175,90,0.22);
    --ruleStroke: rgba(255,175,90,0.54);
  }
  .rule-unique{
    --ruleGlow: rgba(255,225,90,0.20);
    --ruleStroke: rgba(255,225,90,0.54);
  }

  /* ===== VS レイアウト ===== */
  .vsWrap{
    display:grid;
    grid-template-rows: auto auto auto;
    gap:10px;
    margin-bottom: 10px;
  }
  .panel{
    border:1px solid var(--stroke-strong);
    background: rgba(0,0,0,0.20);
    border-radius: 14px;
    padding: 10px 12px;
  }
  .panelRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  .who{
    display:flex;
    align-items:center;
    gap:10px;
    min-width: 0;
  }
  .avatar{
    width: 42px; height: 42px;
    border-radius: 14px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.18);
    background:#fff;
    flex: 0 0 auto;
    display:flex; align-items:center; justify-content:center;
  }
  .whoText{ min-width:0; }
  .name{ font-weight: 900; letter-spacing:.04em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .sub{ color: var(--muted); font-size: 12px; margin-top: 2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .rightMeta{
    display:flex;
    align-items:center;
    gap:10px;
    flex: 0 0 auto;
  }
  .stars{ display:flex; gap:6px; flex-wrap:wrap; }
  .star{
    width: 18px; height: 18px; border-radius: 6px;
    border:1px solid rgba(255,255,255,0.25);
    background: rgba(255,255,255,0.08);
  }
  .star.on{ border-color: rgba(52,243,160,0.55); background: rgba(52,243,160,0.20); }

  .miniBtn{
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.07);
    color: rgba(233,238,246,0.92);
    padding: 8px 10px;
    border-radius: 12px;
    cursor:pointer;
    font-weight: 900;
    letter-spacing:.04em;
    transition: transform .06s ease, filter .12s ease, box-shadow .12s ease, border-color .12s ease;
    font-size: 12px;
  }
  .miniBtn:active{ transform: translateY(1px); }

  .midbar{
    text-align:center;
    padding: 10px 12px;
    border-radius: 14px;
    border:1px solid var(--stroke-strong);
    background: rgba(255,255,255,0.03);
  }
  .midbarTop{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
    flex-wrap:wrap;
  }
  .midbarTop .round{ font-weight: 900; }
  .midbarTop .timer{ font-weight: 900; letter-spacing:.06em; }
  .tiny{ font-size: 12px; color: var(--muted); margin-top: 6px; }
  .vsLine{
    margin-top: 8px;
    font-weight: 900;
    letter-spacing: .18em;
    color: rgba(233,238,246,0.78);
  }

  .midResult{
    margin-top: 8px;
    min-height: 18px;
    font-weight: 900;
    letter-spacing: .04em;
    font-size: 13px;
    color: rgba(233,238,246,0.92);
    opacity: 0;
    transform: translateY(2px);
    transition: opacity .14s ease, transform .14s ease;
  }
  .midResult.show{ opacity: 1; transform: translateY(0); }
  .midResult.ok{ color:#d7fff0; text-shadow: 0 0 14px rgba(52,243,160,0.35); }
  .midResult.ng{ color:#ffe1e1; text-shadow: 0 0 14px rgba(255,77,109,0.28); }
  .midResult.draw{ color: rgba(233,238,246,0.86); text-shadow: 0 0 12px rgba(255,255,255,0.10); }

  /* ===== 問題 ===== */
  .matrix{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 12px;
  }
  .cell{
    border:1px solid var(--stroke-weak);
    background: #fff;
    border-radius: 14px;
    overflow:hidden;
    aspect-ratio: 1 / 1;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .cell.q{ position:relative; }
  .qmark{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size: 34px; color:#111;
    letter-spacing:.05em;
  }

  /* ===== メッセージ ===== */
  .msg{
    margin-top: 12px;
    padding: 10px 12px;
    border-radius: 12px;
    border:1px solid var(--stroke-strong);
    background: rgba(255,255,255,0.04);
    color: var(--muted);
    font-size: 13px;
    line-height: 1.45;
    min-height: 42px;
    text-align:center;
  }
  .msg.ok{ border-color: var(--good); background: rgba(52,243,160,0.12); color: #d7fff0; }
  .msg.ng{ border-color: var(--bad);  background: rgba(255,77,109,0.12); color: #ffe1e1; }

  /* ===== 選択肢 ===== */
  .opts{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:10px;
    width:100%;
    max-width:420px;
    margin:12px auto 0;
  }
  .opt{
    border: 1px solid var(--stroke-weak);
    background: rgba(255,255,255,0.045);
    border-radius: 14px;
    padding: 8px;
    cursor:pointer;
    transition: transform .06s ease, border-color .12s ease, opacity .12s ease;
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-start;
    min-height: 72px;
  }
  .opt:active{ transform: translateY(1px); }
  .opt:hover{ border-color: rgba(52,243,160,0.35); }
  .opt[disabled]{ opacity:.45; cursor:not-allowed; }

  .badge{
    width: 26px; height: 26px;
    border-radius: 9px;
    display:flex; align-items:center; justify-content:center;
    border: 1px solid rgba(52,243,160,0.40);
    color: rgba(52,243,160,0.95);
    background: rgba(0,0,0,0.18);
    font-weight: 900;
    flex: 0 0 auto;
  }
  .thumb{
    width: 56px; height: 56px;
    border-radius: 12px;
    overflow:hidden;
    border:1px solid rgba(255,255,255,0.18);
    background:#fff;
    flex: 0 0 auto;
    display:flex; align-items:center; justify-content:center;
  }

  /* ===== ボタン ===== */
  .row{
    display:flex; gap:10px; flex-wrap:wrap;
    align-items:center; justify-content:space-between;
    margin-top: 12px;
  }
  .btn{
    border: 1px solid rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.07);
    color: rgba(233,238,246,0.92);
    padding: 10px 12px;
    border-radius: 12px;
    cursor:pointer;
    font-weight: 900;
    letter-spacing:.04em;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    transition: transform .06s ease, filter .12s ease, box-shadow .12s ease, border-color .12s ease;
  }
  .btn:active{ transform: translateY(1px); }
  .btn[disabled]{ opacity:.45; cursor:not-allowed; }

  .btn.active{
    border: 1px solid rgba(52,243,160,0.35);
    background: linear-gradient(180deg, rgba(52,243,160,0.20), rgba(52,243,160,0.07));
    color: var(--text);
    box-shadow:
      0 8px 20px rgba(0,0,0,0.35),
      0 0 0 1px rgba(52,243,160,0.20) inset,
      0 0 26px rgba(52,243,160,0.18);
  }

  details{
    margin-top: 12px;
    border:1px solid rgba(255,255,255,0.14);
    border-radius: 12px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.035);
  }
  details > summary{ cursor:pointer; font-weight: 900; color: rgba(233,238,246,0.82); }
  .small{ color: var(--muted); font-size: 12px; line-height: 1.55; margin-top: 8px; white-space: pre-wrap; }

  .matrix svg rect[stroke="#000"]{ stroke: rgba(255,255,255,0.35) !important; }

  /* ===== モーダル（キャラ選択） ===== */
  .modalBg{
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.58);
    display:none;
    align-items: center;
    justify-content: center;
    padding: 18px;
    z-index: 9999;
  }
  .modalBg.show{ display:flex; }
  .modal{
    width: min(560px, 100%);
    border-radius: 16px;
    border:1px solid rgba(255,255,255,0.18);
    background: rgba(12,16,22,0.94);
    box-shadow: 0 20px 60px rgba(0,0,0,0.55);
    padding: 14px;
  }
  .modalHead{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap:10px;
    margin-bottom: 10px;
  }
  .modalTitle{ font-weight: 900; letter-spacing:.06em; }
  .gridChars{
    display:grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap:10px;
  }
  .charBtn{
    border:1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.06);
    border-radius: 14px;
    padding: 10px;
    cursor:pointer;
    display:flex;
    gap:10px;
    align-items:center;
    transition: transform .06s ease, border-color .12s ease;
  }
  .charBtn:active{ transform: translateY(1px); }
  .charBtn:hover{ border-color: rgba(52,243,160,0.30); }
  .charName{
    font-weight: 900;
    font-size: 13px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .charIcon{
    width: 36px; height: 36px;
    border-radius: 14px;
    overflow:hidden;
    background:#fff;
    border:1px solid rgba(255,255,255,0.18);
    flex: 0 0 auto;
    display:flex; align-items:center; justify-content:center;
  }

  @media (max-width: 420px){
    .opts{ grid-template-columns: repeat(2, minmax(0, 1fr)); max-width: 360px; }
    .gridChars{ grid-template-columns: repeat(2, minmax(0,1fr)); }
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div><h1>IQ大戦（MVP）</h1></div>
    <div class="pill" id="statusPill">未開始</div>
  </div>

  <div class="card" id="card">
    <div class="vsWrap">
      <!-- 上：CPU -->
      <div class="panel">
        <div class="panelRow">
          <div class="who">
            <div class="avatar" id="cpuAvatar"></div>
            <div class="whoText">
              <div class="name" id="cpuName">CPU</div>
              <div class="sub" id="cpuSub">Rank 2 / ???</div>
            </div>
          </div>
          <div class="rightMeta">
            <div class="stars" id="cpuStars"></div>
          </div>
        </div>
      </div>

      <!-- 中央：VS + Round/Timer + Result -->
      <div class="midbar">
        <div class="midbarTop">
          <div class="round" id="roundText">Round 1 / 5</div>
          <div class="timer" id="timerText">60.0</div>
        </div>
        <div class="tiny">同時回答＋早さ判定 / 引き分けは再戦 / 3先取</div>
        <div class="vsLine">VS</div>
        <div class="midResult" id="midResult" aria-live="polite"></div>
      </div>

      <!-- 下：Player -->
      <div class="panel">
        <div class="panelRow">
          <div class="who">
            <div class="avatar" id="playerAvatar"></div>
            <div class="whoText">
              <div class="name" id="playerName">Player</div>
              <div class="sub" id="playerSub">Rank 2 / ???</div>
            </div>
          </div>
          <div class="rightMeta">
            <button class="miniBtn" id="pickCharBtn">アイコン変更</button>
            <div class="stars" id="playerStars"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="matrix" id="matrix"></div>

    <div class="msg" id="msg">「開始」を押すと同時にスタートします。</div>
    <div class="opts" id="opts"></div>

    <div class="row">
      <button class="btn" id="startBtn">開始</button>
      <button class="btn" id="nextBtn" disabled>次へ</button>
    </div>

    <details>
      <summary>（開発用）今回の生成ルールを見る</summary>
      <div class="small" id="debug"></div>
    </details>
  </div>
</div>

<!-- モーダル -->
<div class="modalBg" id="modalBg" role="dialog" aria-modal="true" aria-label="キャラ選択">
  <div class="modal">
    <div class="modalHead">
      <div class="modalTitle">デカブサキャラから選ぶ</div>
      <button class="miniBtn" id="closeModalBtn">閉じる</button>
    </div>
    <div class="gridChars" id="charGrid"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     対戦ルール
     ========================= */
  const MAX_ROUNDS = 5;
  const WIN_NEED  = 3;
  const LIMIT_SEC = 60; // 1分

  let playerRank = 2;
  let cpuRank    = 2;

  const LABELS = ["A","B","C","D","E","F"];

  /* =========================
     キャラ（仮）
     ========================= */
  const CHARACTERS = [
    { id:"dekabusa",   name:"デカブサ" },
    { id:"ani",       name:"デカブサ兄" },
    { id:"otouto",    name:"デカブサ弟" },
    { id:"kabao",     name:"カバオ" },
    { id:"hachibou",  name:"ハチボウ" },
    { id:"yumeo",     name:"ユメオ" },
    { id:"juuzou",    name:"十三（ジュウゾウ）" },
    { id:"torasan",   name:"とらさん" },
    { id:"lionmaru",  name:"ライオン丸" },
    { id:"namaken",   name:"ナマケン" },
    { id:"hanao",     name:"ハナオ" },
    { id:"bird",      name:"バード" },
    { id:"kanemon",   name:"カンえもん" },
    { id:"taiga",     name:"タイガ" },
    { id:"gori",      name:"ゴリさん" },
  ];

  // 今は「アイコン＝白地に文字」の簡易版（画像差し替えも後で可能）
  function avatarSVG(label, size=42){
    const s = size;
    const text = (label || "?").slice(0,3);
    return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}" aria-hidden="true">
      <rect x="0" y="0" width="${s}" height="${s}" rx="${Math.round(s*0.33)}" ry="${Math.round(s*0.33)}" fill="#fff"/>
      <text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle"
        font-family="-apple-system,BlinkMacSystemFont,'Hiragino Kaku Gothic ProN','Noto Sans JP',sans-serif"
        font-size="${Math.round(s*0.28)}" font-weight="900" fill="#111">${escapeXML(text)}</text>
    </svg>`;
  }
  function escapeXML(str){
    return String(str).replace(/[<>&"']/g, s => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[s]));
  }

  /* =========================
     DOM
     ========================= */
  const $card = document.getElementById("card");
  const $matrix = document.getElementById("matrix");
  const $opts = document.getElementById("opts");
  const $msg = document.getElementById("msg");
  const $debug = document.getElementById("debug");

  const $pill = document.getElementById("statusPill");
  const $roundText = document.getElementById("roundText");
  const $timerText = document.getElementById("timerText");
  const $midResult = document.getElementById("midResult");

  const $startBtn = document.getElementById("startBtn");
  const $nextBtn  = document.getElementById("nextBtn");

  const $playerStars = document.getElementById("playerStars");
  const $cpuStars = document.getElementById("cpuStars");

  const $playerSub = document.getElementById("playerSub");
  const $cpuSub = document.getElementById("cpuSub");

  const $playerAvatar = document.getElementById("playerAvatar");
  const $cpuAvatar = document.getElementById("cpuAvatar");
  const $playerName = document.getElementById("playerName");
  const $cpuName = document.getElementById("cpuName");

  // modal
  const $modalBg = document.getElementById("modalBg");
  const $charGrid = document.getElementById("charGrid");
  const $pickCharBtn = document.getElementById("pickCharBtn");
  const $closeModalBtn = document.getElementById("closeModalBtn");

  /* =========================
     状態
     ========================= */
  const state = {
    matchEnded:false,
    round:1,
    pScore:0,
    eScore:0,

    running:false,
    t0:0,
    timerId:null,
    
    roundEnded:false,

    q:null,
    pPick:null,
    pTime:null,
    ePick:null,
    eTime:null,
    eTimerId:null,

    midResultTid:null,

    playerChar: CHARACTERS[0],
    cpuChar: CHARACTERS[1],
  };

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const now = ()=>performance.now();

  function setPill(t){ $pill.textContent = t; }

  function setMsg(text, kind=""){
    $msg.classList.remove("ok","ng");
    if(kind) $msg.classList.add(kind);
    $msg.textContent = text;
  }

  function clearMidResult(){
    if(state.midResultTid){ clearTimeout(state.midResultTid); state.midResultTid=null; }
    $midResult.classList.remove("show","ok","ng","draw");
    $midResult.textContent = "";
  }
  function showMidResult(text, kind="draw", ms=2200){
    clearMidResult();
    $midResult.textContent = text;
    $midResult.classList.add("show");
    if(kind) $midResult.classList.add(kind);
    state.midResultTid = setTimeout(()=>clearMidResult(), ms);
  }

  function setActiveButton(which){
    $startBtn.classList.remove("active");
    $nextBtn.classList.remove("active");
    if(which==="start") $startBtn.classList.add("active");
    if(which==="next")  $nextBtn.classList.add("active");
  }

  function drawStars($el, on){
    $el.innerHTML = "";
    for(let i=0;i<WIN_NEED;i++){
      const d = document.createElement("div");
      d.className = "star" + (i<on ? " on" : "");
      $el.appendChild(d);
    }
  }

  function updateHeader(){
    $roundText.textContent = `Round ${state.round} / ${MAX_ROUNDS}`;

    $playerSub.textContent = `Rank ${playerRank} / ${state.playerChar.name}`;
    $cpuSub.textContent    = `Rank ${cpuRank} / ${state.cpuChar.name}`;

    $playerAvatar.innerHTML = avatarSVG(state.playerChar.name, 42);
    $cpuAvatar.innerHTML    = avatarSVG(state.cpuChar.name, 42);

    drawStars($playerStars, state.pScore);
    drawStars($cpuStars, state.eScore);
  }

  function setOptionsEnabled(on){
    [...$opts.querySelectorAll("button.opt")].forEach(b => b.disabled = !on);
  }

  function stopTimer(){
    if(state.timerId){ clearInterval(state.timerId); state.timerId=null; }
    state.running = false;
  }

  function startTimer(){
    stopTimer();
    state.running = true;
    state.t0 = now();

    const tick = ()=>{
      const t = (now()-state.t0)/1000;
      const left = clamp(LIMIT_SEC - t, 0, LIMIT_SEC);
      $timerText.textContent = left.toFixed(1);
      if(left<=0) onTimeout();
    };
    tick();
    state.timerId = setInterval(tick, 50);
  }

  function resetPicks(){
  state.pPick = null; state.pTime = null;
  state.ePick = null; state.eTime = null;
  state.roundEnded = false; // ←追加
  if(state.eTimerId){ clearTimeout(state.eTimerId); state.eTimerId=null; }
}

  function onTimeout(){
    if(!state.running) return;
    stopTimer();
    setOptionsEnabled(false);

    if(state.pPick===null){ state.pPick = -1; state.pTime = LIMIT_SEC; }
    if(state.ePick===null){ state.ePick = -1; state.eTime = LIMIT_SEC; }
    judgeAndFinish();
  }

  function finishRoundWithWinner(winner){ // "P" or "E" or "DRAW"
  if(state.roundEnded) return;
  state.roundEnded = true;

  stopTimer();
  setOptionsEnabled(false);
  if(state.eTimerId){ clearTimeout(state.eTimerId); state.eTimerId=null; } // CPU未回答なら止める

  if(winner === "P"){
    state.pScore++;
    setMsg(`Player 正解（${(state.pTime ?? 0).toFixed(2)}s）✅`, "ok");
    showMidResult("PLAYER +1", "ok");
  }else if(winner === "E"){
    state.eScore++;
    setMsg(`CPU 正解（${(state.eTime ?? 0).toFixed(2)}s）❌`, "ng");
    showMidResult("CPU +1", "ng");
  }else{
    setMsg(`両者不正解。引き分け → 再戦`, "");
    showMidResult("DRAW", "draw");
    setPill("引き分け");
    $nextBtn.disabled = false;
    $startBtn.disabled = true;
    setActiveButton("next");
    updateHeader();
    return;
  }

  updateHeader();

  if(state.pScore>=WIN_NEED || state.eScore>=WIN_NEED){
    state.matchEnded = true;
    setPill("対戦終了");
    $startBtn.disabled = true;
    $nextBtn.disabled = true;
    setActiveButton(null);

    const win = state.pScore>state.eScore ? "Player WIN" : "CPU WIN";
    setMsg(`${win}（${state.pScore}-${state.eScore}）`, state.pScore>state.eScore ? "ok" : "ng");
    showMidResult(`${win} (${state.pScore}-${state.eScore})`, state.pScore>state.eScore ? "ok" : "ng", 3500);
    return;
  }

  state.round++;
  if(state.round > MAX_ROUNDS){
    state.matchEnded = true;
    setPill("対戦終了");
    $startBtn.disabled = true;
    $nextBtn.disabled = true;
    setActiveButton(null);
    setMsg(`最大問題数に到達（${state.pScore}-${state.eScore}）`, "");
    showMidResult(`END (${state.pScore}-${state.eScore})`, "draw", 3000);
    return;
  }

  setPill("次へ");
  $nextBtn.disabled = false;
  $startBtn.disabled = true;
  setActiveButton("next");
}

function evaluateAfterPick(lastPicker){ // "P" or "E"
  if(state.roundEnded) return;
  const ans = state.q.ansIndex;

  const pAnswered = state.pPick !== null;
  const eAnswered = state.ePick !== null;

  const pCorrect = pAnswered && (state.pPick === ans);
  const eCorrect = eAnswered && (state.ePick === ans);

  // ★新ルール：先に答えた方が正解なら、その瞬間に勝ち（相手の回答を待たない）
  if(lastPicker === "P" && pCorrect){
    finishRoundWithWinner("P");
    return;
  }
  if(lastPicker === "E" && eCorrect){
    finishRoundWithWinner("E");
    return;
  }

  // 先に答えた側が不正解なら、相手が答える/タイムアウトを待つ
  // ただし両者が答えて両方不正解なら即DRAWで良い
  if(pAnswered && eAnswered){
    if(pCorrect && !eCorrect) return finishRoundWithWinner("P"); // 念のため
    if(!pCorrect && eCorrect) return finishRoundWithWinner("E"); // 念のため
    return finishRoundWithWinner("DRAW");
  }
}

function onPlayerPick(idx){
  if(!state.running || state.roundEnded) return;
  if(state.pPick!==null) return;
  state.pPick = idx;
  state.pTime = (now()-state.t0)/1000;
  evaluateAfterPick("P");
}

// 旧maybeFinishSoon/judgeAndFinishは不要になるけど、呼ばれてる箇所があるので最小化して残す
function maybeFinishSoon(){
  // CPU側タイマーから呼ばれても evaluateAfterPick で判定する
  // ※どちらが最後に答えたかは、CPU側からは "E" として呼ぶ
  evaluateAfterPick("E");
}

    $nextBtn.disabled = false;
    $startBtn.disabled = true;
    setActiveButton("next");
  }

  function nextStep(){
    if(state.matchEnded) return;
    clearMidResult();
    setPill("待機");
    setMsg("「開始」を押すとスタートします。");
    $startBtn.disabled = false;
    $nextBtn.disabled = true;
    setActiveButton("start");
    $timerText.textContent = LIMIT_SEC.toFixed(1);
  }

  /* =========================
     キャラ選択（モーダル）
     ========================= */
  function openModal(){
    $modalBg.classList.add("show");
  }
  function closeModal(){
    $modalBg.classList.remove("show");
  }
  function buildCharGrid(){
    $charGrid.innerHTML = "";
    CHARACTERS.forEach(ch => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "charBtn";
      b.addEventListener("click", ()=>{
        state.playerChar = ch;
        updateHeader();
        closeModal();
      });

      const icon = document.createElement("div");
      icon.className = "charIcon";
      icon.innerHTML = avatarSVG(ch.name, 36);

      const name = document.createElement("div");
      name.className = "charName";
      name.textContent = ch.name;

      b.appendChild(icon);
      b.appendChild(name);
      $charGrid.appendChild(b);
    });
  }

  $pickCharBtn.addEventListener("click", openModal);
  $closeModalBtn.addEventListener("click", closeModal);
  $modalBg.addEventListener("click", (e)=>{ if(e.target === $modalBg) closeModal(); });

  /* =========================
     ここから：問題生成・描画（ガチIQ資産）
     ========================= */

  // ========= Utils =========
  const deepEq = (a,b) => a.length===b.length && a.every((v,i)=>v===b[i]);
  const rndInt = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const shuffle = (arr) => {
    const a = arr.slice();
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  };
  const countOnes = (c) => c.reduce((s,v)=>s+(v?1:0),0);
  const cellKey = (c) => c.join("");

  // ========= Theme =========
  const THEMES = {
  logic_sq:   { id:"logic_sq",   shape:"square", fill:"solid",   bg:"white" },
  logic_out:  { id:"logic_out",  shape:"square", fill:"outline", bg:"white" },
  motion_dot: { id:"motion_dot", shape:"circle", fill:"solid",   bg:"white" },
  tri_fill:   { id:"tri_fill",   shape:"tri",    fill:"solid",   bg:"white" },
};
  const POOL_BY_TYPE = {
    matrix3x3:     ["logic_sq","logic_out","tri_fill"],
    relation2x2:   ["logic_sq","logic_out"],
    triomino4x4:   ["logic_sq"],
    countAdd3x3:   ["logic_out","logic_sq"],
    shiftChain3x3: ["motion_dot","logic_out"],
    mirrorXor3x3:  ["logic_out","logic_sq","tri_fill"],
  };
  function pickThemeForType(type){
    const poolKeys = POOL_BY_TYPE[type] || ["logic_sq"];
    const pool = poolKeys.map(k => THEMES[k]).filter(Boolean);
    return pool[Math.floor(Math.random()*pool.length)];
  }

  // triomino key
  const triKey = (op) => {
    const e = op.empty2x2.join(",");
    const s = op.symbols3.slice().sort().join("|");
    return `${e}::${s}`;
  };

  // ========= Cell ops =========
  function rot90(c){ return [c[6],c[3],c[0], c[7],c[4],c[1], c[8],c[5],c[2]]; }
  function rot180(c){ return rot90(rot90(c)); }
  function flipH(c){ return [c[2],c[1],c[0], c[5],c[4],c[3], c[8],c[7],c[6]]; }
  function shiftRight(c){ return [c[2],c[0],c[1], c[5],c[3],c[4], c[8],c[6],c[7]]; }
  function shiftDown(c){ return [c[6],c[7],c[8], c[0],c[1],c[2], c[3],c[4],c[5]]; }

  function xor(a,b){ return a.map((v,i)=> (v ^ b[i]) ); }
  function or(a,b){  return a.map((v,i)=> (v | b[i]) ); }
  function and(a,b){ return a.map((v,i)=> (v & b[i]) ); }
  function not(a){   return a.map(v => v ? 0 : 1); }
  function xnor(a,b){ return not(xor(a,b)); }

  function swap2(c){
    const a = c.slice();
    const i = rndInt(0,8);
    let j = rndInt(0,8);
    if (j===i) j = (j+1)%9;
    [a[i],a[j]] = [a[j],a[i]];
    return a;
  }
  function toggleK(c, k=1){
    const a = c.slice();
    const idx = shuffle([...Array(9)].map((_,i)=>i)).slice(0, k);
    idx.forEach(i => a[i] = a[i] ? 0 : 1);
    return a;
  }
  function randCellDense(minOnes=2, maxOnes=4){
    const k = rndInt(minOnes, maxOnes);
    const pos = shuffle([...Array(9)].map((_,i)=>i)).slice(0,k);
    const c = Array(9).fill(0);
    pos.forEach(i => c[i]=1);
    return c;
  }

  // ========= SVG render =========
  function cellToSVG(c, size=140, theme=THEMES.logic_sq){
    const s = size/3;
    const bgFill = (theme.bg==="black") ? "#000" : "#fff";
    const fgFill = (theme.bg==="black") ? "#fff" : "#000";

    const drawSquare = (x,y,w,h,fillMode) => {
      if (fillMode==="outline"){
        return `<rect x="${x+4}" y="${y+4}" width="${w-8}" height="${h-8}" fill="none" stroke="${fgFill}" stroke-width="5"/>`;
      }
      if (fillMode==="hatch"){
        const id = `h${Math.random().toString(16).slice(2)}`;
        return `
          <defs>
            <pattern id="${id}" width="12" height="12" patternUnits="userSpaceOnUse" patternTransform="rotate(45)">
              <line x1="0" y1="0" x2="0" y2="12" stroke="${fgFill}" stroke-width="4"/>
            </pattern>
          </defs>
          <rect x="${x+4}" y="${y+4}" width="${w-8}" height="${h-8}" fill="url(#${id})" />
        `;
      }
      return `<rect x="${x}" y="${y}" width="${w}" height="${h}" fill="${fgFill}"/>`;
    };

    const drawCircle = (x,y,w,h,fillMode) => {
      const cx = x + w/2, cy = y + h/2;
      const r  = Math.min(w,h)*0.32;
      if (fillMode==="outline"){
        return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="${fgFill}" stroke-width="5"/>`;
      }
      return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${fgFill}"/>`;
    };

    const drawTri = (x,y,w,h,fillMode) => {
      const p = 8;
      const x1 = x + w/2, y1 = y + p;
      const x2 = x + w - p, y2 = y + h - p;
      const x3 = x + p,     y3 = y + h - p;
      if (fillMode==="outline"){
        return `<path d="M ${x1} ${y1} L ${x2} ${y2} L ${x3} ${y3} Z" fill="none" stroke="${fgFill}" stroke-width="5"/>`;
      }
      return `<path d="M ${x1} ${y1} L ${x2} ${y2} L ${x3} ${y3} Z" fill="${fgFill}"/>`;
    };

    let marks = "";
    for(let i=0;i<9;i++){
      if(!c[i]) continue;
      const x = (i%3)*s, y = Math.floor(i/3)*s;
      if (theme.shape==="circle") marks += drawCircle(x,y,s,s,theme.fill);
      else if (theme.shape==="tri") marks += drawTri(x,y,s,s,theme.fill);
      else marks += drawSquare(x,y,s,s,theme.fill);
    }

    const grid =
      `<path d="M ${s} 0 V ${size} M ${2*s} 0 V ${size} M 0 ${s} H ${size} M 0 ${2*s} H ${size}"
        stroke="rgba(255,255,255,0.35)" stroke-width="3" />
       <path d="M ${s} 0 V ${size} M ${2*s} 0 V ${size} M 0 ${s} H ${size} M 0 ${2*s} H ${size}"
        stroke="rgba(0,0,0,0.18)" stroke-width="1" />`;

    const strokeOuter = (theme.bg==="black") ? "rgba(255,255,255,0.65)" : "#000";

    return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-hidden="true">
      <rect width="${size}" height="${size}" fill="${bgFill}" stroke="${strokeOuter}" stroke-width="2"/>
      ${marks}${grid}
    </svg>`;
  }

  function buildOptions(answer){
    const candidates = [];
    const add = (c) => {
      const k = cellKey(c);
      if (!candidates.some(x => cellKey(x)===k)) candidates.push(c);
    };

    add(answer);
    add(rot90(answer));
    add(rot180(answer));
    add(flipH(answer));
    add(shiftRight(answer));
    add(shiftDown(answer));
    add(xor(answer, rot90(answer)));
    add(toggleK(answer,1));
    add(toggleK(answer,2));
    add(swap2(answer));

    const filtered = candidates.filter(c => {
      const ones = countOnes(c);
      return ones >= 1 && ones <= 8;
    });

    const distractPool = filtered.filter(c => !deepEq(c, answer));
    const distractors = shuffle(distractPool).slice(0, 5);

    let tries = 0;
    while (distractors.length < 5 && tries < 80){
      tries++;
      const variant = toggleK(answer, rndInt(1,2));
      if (!deepEq(variant, answer) && !distractors.some(d => deepEq(d, variant))){
        const ones = countOnes(variant);
        if (ones >= 1 && ones <= 8) distractors.push(variant);
      }
    }

    const options = shuffle([answer, ...distractors]).slice(0,6);
    const ansIndex = options.findIndex(o => deepEq(o, answer));
    return { options, ansIndex };
  }

  // triomino
  const SYMBOLS = ["circle","square","triangle","dot","bullseye","circle_cross","diamond","circle_slash"];

  function symbolSVG(sym, size=44){
    const s = size;
    const cx = s/2, cy = s/2;
    const stroke = "#111";
    const sw = 3.2;
    const bg = `<rect width="${s}" height="${s}" rx="${Math.max(8, s*0.18)}" ry="${Math.max(8, s*0.18)}" fill="#fff"/>`;

    const dot = `<circle cx="${cx}" cy="${cy}" r="${s*0.13}" fill="${stroke}" />`;
    const circle = `<circle cx="${cx}" cy="${cy}" r="${s*0.22}" fill="none" stroke="${stroke}" stroke-width="${sw}" />`;
    const square = `<rect x="${s*0.30}" y="${s*0.30}" width="${s*0.40}" height="${s*0.40}" fill="none" stroke="${stroke}" stroke-width="${sw}" />`;
    const tri = `<path d="M ${cx} ${s*0.24} L ${s*0.74} ${s*0.72} L ${s*0.26} ${s*0.72} Z" fill="none" stroke="${stroke}" stroke-width="${sw}" />`;
    const bull = `
      <circle cx="${cx}" cy="${cy}" r="${s*0.26}" fill="none" stroke="${stroke}" stroke-width="${sw}" />
      <circle cx="${cx}" cy="${cy}" r="${s*0.10}" fill="${stroke}" />
    `;
    const circle_cross = `
      <circle cx="${cx}" cy="${cy}" r="${s*0.26}" fill="none" stroke="${stroke}" stroke-width="${sw}" />
      <path d="M ${cx} ${s*0.22} V ${s*0.78} M ${s*0.22} ${cy} H ${s*0.78}"
        stroke="${stroke}" stroke-width="${sw}" stroke-linecap="round"/>
    `;
    const diamond = `<path d="M ${cx} ${s*0.22} L ${s*0.78} ${cy} L ${cx} ${s*0.78} L ${s*0.22} ${cy} Z"
      fill="none" stroke="${stroke}" stroke-width="${sw}"/>`;
    const circle_slash = `
      <circle cx="${cx}" cy="${cy}" r="${s*0.26}" fill="none" stroke="${stroke}" stroke-width="${sw}" />
      <path d="M ${s*0.28} ${s*0.72} L ${s*0.72} ${s*0.28}"
        stroke="${stroke}" stroke-width="${sw}" stroke-linecap="round"/>
    `;

    let shape = circle;
    if (sym==="square") shape = square;
    else if (sym==="triangle") shape = tri;
    else if (sym==="dot") shape = dot;
    else if (sym==="bullseye") shape = bull;
    else if (sym==="circle_cross") shape = circle_cross;
    else if (sym==="diamond") shape = diamond;
    else if (sym==="circle_slash") shape = circle_slash;

    return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}" aria-hidden="true">${bg}${shape}</svg>`;
  }

  function triominoOptionSVG(opt, size=64){
    const s = size;
    const pad = 6;
    const cell = (s - pad*2) / 2;
    const [er, ec] = opt.empty2x2;

    let idx = 0;
    let parts = `<rect width="${s}" height="${s}" rx="12" ry="12" fill="#fff" stroke="rgba(0,0,0,0.18)" stroke-width="2"/>`;
    for(let r=0;r<2;r++){
      for(let c=0;c<2;c++){
        const x = pad + c*cell;
        const y = pad + r*cell;
        parts += `<rect x="${x}" y="${y}" width="${cell}" height="${cell}" fill="none" stroke="rgba(0,0,0,0.12)" stroke-width="2"/>`;
        if (r===er && c===ec) continue;
        const sym = opt.symbols3[idx++];
        const icon = symbolSVG(sym, Math.floor(cell*0.78));
        parts += `<g transform="translate(${x + cell*0.11}, ${y + cell*0.11})">${icon}</g>`;
      }
    }
    return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}" aria-hidden="true">${parts}</svg>`;
  }

  // rules
  const RULES = [
    { id:"xor",  name:"右 = 左 XOR 中央",  f:(L,M)=>xor(L,M) },
    { id:"or",   name:"右 = 左 OR 中央",   f:(L,M)=>or(L,M)  },
    { id:"and",  name:"右 = 左 AND 中央",  f:(L,M)=>and(L,M) },
    { id:"xnor", name:"右 = 左 XNOR 中央", f:(L,M)=>xnor(L,M)},
    { id:"not",  name:"右 = NOT(左)",      f:(L,M)=>not(L)   },
  ];
  const getRule = (id) => RULES.find(r => r.id===id);

  const RULESETS = [
    { row:"xor",  col:"xor"  },
    { row:"or",   col:"xor"  },
    { row:"xor",  col:"or"   },
    { row:"and",  col:"xor"  },
    { row:"xor",  col:"and"  },
    { row:"or",   col:"and"  },
    { row:"and",  col:"or"   },
    { row:"xnor", col:"xor"  },
    { row:"xor",  col:"xnor" },
    { row:"xnor", col:"xnor" },
    { row:"not",  col:"xor"  },
    { row:"xor",  col:"not"  },
    { row:"not",  col:"not"  },
  ];

  function genMatrixRowColOps(){
    const pickSet = RULESETS[Math.floor(Math.random()*RULESETS.length)];
    const rowRule = getRule(pickSet.row);
    const colRule = getRule(pickSet.col);

    function makeSolvedGrid(){
      const a11 = randCellDense(2,4);
      const a12 = randCellDense(2,4);
      const a21 = randCellDense(2,4);
      const a22 = randCellDense(2,4);

      const a13 = rowRule.f(a11, a12);
      const a23 = rowRule.f(a21, a22);

      const a31 = colRule.f(a11, a21);
      const a32 = colRule.f(a12, a22);

      const fromRow = rowRule.f(a31, a32);
      const fromCol = colRule.f(a13, a23);
      if (!deepEq(fromRow, fromCol)) return null;

      const a33 = fromRow;
      return [[a11,a12,a13],[a21,a22,a23],[a31,a32,a33]];
    }

    let grid = null;
    for (let t=0;t<1200;t++){
      const g = makeSolvedGrid();
      if (!g) continue;
      const all = g.flat();
      const onesList = all.map(countOnes);
      const tooExtreme = onesList.some(x => x <= 1 || x >= 8);
      const uniq = new Set(all.map(cellKey)).size;
      if (tooExtreme) continue;
      if (uniq < 7) continue;
      grid = g; break;
    }
    if (!grid){
      const a11 = randCellDense(2,4);
      const a12 = randCellDense(2,4);
      const a21 = randCellDense(2,4);
      const a22 = randCellDense(2,4);
      const a13 = xor(a11,a12);
      const a23 = xor(a21,a22);
      const a31 = xor(a11,a21);
      const a32 = xor(a12,a22);
      const a33 = xor(a31,a32);
      grid = [[a11,a12,a13],[a21,a22,a23],[a31,a32,a33]];
    }

    const answer = grid[2][2];
    const gridWithHole = [[grid[0][0],grid[0][1],grid[0][2]],[grid[1][0],grid[1][1],grid[1][2]],[grid[2][0],grid[2][1],null]];
    const { options, ansIndex } = buildOptions(answer);

    const debugText =
`Type: matrix3x3
RowRule: ${rowRule.name} (${rowRule.id})
ColRule: ${colRule.name} (${colRule.id})
✅ 行と列が別でも両方成立する問題のみ採用`;

    return { type:"matrix3x3", size:3, grid:gridWithHole, answer, options, ansIndex, debugText, rowRuleId:rowRule.id, colRuleId:colRule.id };
  }

  function genRelation2x2Rotate(){
    const A = randCellDense(2,5);
    const B = rot90(A);
    const C = randCellDense(2,5);
    const answer = rot90(C);

    const grid = [[A, B],[C, null]];
    const { options, ansIndex } = buildOptions(answer);
    const debugText = `Type: relation2x2\nRule: A→B は 90°回転 / C→? も 90°回転`;

    return { type:"relation2x2", size:2, grid, answer, options, ansIndex, debugText, rowRuleId:"rot2", colRuleId:"rot2" };
  }

  function pickValidLHole4x4(){
    const inBounds = (r,c)=> (r>=0 && r<4 && c>=0 && c<4);
    const makeL = (r,c,o)=>{
      const a=[r,c];
      let b,c2;
      if (o===0){ b=[r,c+1]; c2=[r+1,c]; }
      if (o===1){ b=[r,c-1]; c2=[r+1,c]; }
      if (o===2){ b=[r,c+1]; c2=[r-1,c]; }
      if (o===3){ b=[r,c-1]; c2=[r-1,c]; }
      return [a,b,c2];
    };
    while(true){
      const r = rndInt(0,3), c = rndInt(0,3), o = rndInt(0,3);
      const cells = makeL(r,c,o);
      if (cells.every(([rr,cc])=>inBounds(rr,cc))) return { cells, orientation:o };
    }
  }
  function lOrientationToEmpty2x2(orientation){
    if (orientation===0) return [1,1];
    if (orientation===1) return [1,0];
    if (orientation===2) return [0,1];
    return [0,0];
  }
  function genTriominoPairs4x4(){
    const hole = pickValidLHole4x4();
    const holeCells = hole.cells;
    const empty2x2 = lOrientationToEmpty2x2(hole.orientation);

    const pool = shuffle([...SYMBOLS]);
    const singles = pool.slice(0,3);
    const doubles = pool.slice(3,8);

    const fill = [];
    singles.forEach(s=>fill.push(s));
    doubles.forEach(d=>{ fill.push(d); fill.push(d); });
    const fillSyms = shuffle(fill);

    const isHole = (r,c)=> holeCells.some(([rr,cc])=>rr===r && cc===c);

    const grid = Array.from({length:4}, ()=>Array(4).fill(null));
    let idx = 0;
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        if (isHole(r,c)) continue;
        grid[r][c] = fillSyms[idx++];
      }
    }

    const answerSymbols = shuffle([...singles]);

    const options = [];
    options.push({ empty2x2, symbols3: answerSymbols.slice() });
    while(options.length < 6){
      const cand = shuffle([...SYMBOLS]).slice(0,3);
      const set = new Set(cand);
      const allSingles = singles.every(s => set.has(s));
      if (allSingles) continue;
      const sCount = cand.filter(x=>singles.includes(x)).length;
      if (sCount === 0) continue;

      const op = { empty2x2, symbols3: cand };
      const k = triKey(op);
      if (options.some(x => triKey(x)===k)) continue;
      options.push(op);
    }

    const shuffled = shuffle(options);
    const ansIndex = shuffled.findIndex(op => singles.every(s => new Set(op.symbols3).has(s)));

    const debugText =
`Type: triomino4x4
Rule: 8種類の記号が最終的に2回ずつ出る（=16マス）
Singles: ${singles.join(", ")}
HoleCells: ${holeCells.map(x=>`(${x[0]},${x[1]})`).join(" ")}`;

    return { type:"triomino4x4", size:4, grid, holeCells, options:shuffled, ansIndex, debugText, rowRuleId:"triomino", colRuleId:"triomino" };
  }

  function genCountAdd(){
    const makeByCount = (k) => {
      const pos = shuffle([...Array(9)].map((_,i)=>i)).slice(0, k);
      const c = Array(9).fill(0);
      pos.forEach(i => c[i]=1);
      return c;
    };
    const a11k = rndInt(1,3), a12k = rndInt(1,3), a21k = rndInt(1,3), a22k = rndInt(1,3);
    const a11 = makeByCount(a11k), a12 = makeByCount(a12k), a21 = makeByCount(a21k), a22 = makeByCount(a22k);
    const a13 = makeByCount(Math.min(8, a11k + a12k));
    const a23 = makeByCount(Math.min(8, a21k + a22k));
    const a31 = makeByCount(Math.min(8, a11k + a21k));
    const a32 = makeByCount(Math.min(8, a12k + a22k));
    const target = Math.min(8, (a11k+a12k) + (a21k+a22k));
    const a33 = makeByCount(target);

    const grid = [[a11,a12,a13],[a21,a22,a23],[a31,a32,null]];
    const answer = a33;
    const { options, ansIndex } = buildOptions(answer);
    const debugText = `Type: countAdd3x3\nRule: 右は(左+中央)の黒マス数になる（配置はランダムテンプレ）`;

    return { type:"countAdd3x3", size:3, grid, answer, options, ansIndex, debugText, rowRuleId:"unique", colRuleId:"unique" };
  }

  function genShiftChain(){
    const base = randCellDense(2,4);
    const a11 = base;
    const a12 = shiftRight(a11);
    const a13 = shiftRight(a12);
    const a21 = shiftDown(a11);
    const a22 = shiftRight(a21);
    const a23 = shiftRight(a22);
    const a31 = shiftDown(a21);
    const a32 = shiftRight(a31);
    const a33 = shiftRight(a32);

    const grid = [[a11,a12,a13],[a21,a22,a23],[a31,a32,null]];
    const answer = a33;
    const { options, ansIndex } = buildOptions(answer);
    const debugText = `Type: shiftChain3x3\nRule: 右へ1つシフト（列方向）。下は下へ1つシフト（行方向）。`;

    return { type:"shiftChain3x3", size:3, grid, answer, options, ansIndex, debugText, rowRuleId:"rot2", colRuleId:"rot2" };
  }

  function genMirrorXor(){
    const a11 = randCellDense(2,4);
    const a12 = randCellDense(2,4);
    const a21 = randCellDense(2,4);
    const a22 = randCellDense(2,4);

    const a13 = xor(a11, flipH(a11));
    const a23 = xor(a21, flipH(a21));
    const a31 = xor(a12, flipH(a12));
    const a32 = xor(a22, flipH(a22));
    const a33 = xor(a13, a23);

    const grid = [[a11,a12,a13],[a21,a22,a23],[a31,a32,null]];
    const answer = a33;
    const { options, ansIndex } = buildOptions(answer);
    const debugText = `Type: mirrorXor3x3\nRule: 右 = 左 XOR 左の左右反転（対称合成）`;

    return { type:"mirrorXor3x3", size:3, grid, answer, options, ansIndex, debugText, rowRuleId:"xor", colRuleId:"xor" };
  }

  const GENERATORS = [
    { w: 60, fn: genMatrixRowColOps },
    { w: 20, fn: genRelation2x2Rotate },
    { w: 20, fn: genTriominoPairs4x4 },
    { w: 10, fn: genCountAdd },
    { w: 5,  fn: genShiftChain },
    { w: 5,  fn: genMirrorXor },
  ];
  function pickGenerator(){
    const sum = GENERATORS.reduce((s,x)=>s+x.w,0);
    let r = Math.random()*sum;
    for (const g of GENERATORS){
      r -= g.w;
      if (r <= 0) return g.fn;
    }
    return GENERATORS[0].fn;
  }

  function applyRuleColor(q){
    if(!$card || !q) return;
    [...$card.classList].forEach(c => { if(c.startsWith("rule-")) $card.classList.remove(c); });
    if (q.type === "relation2x2"){ $card.classList.add("rule-rot2"); return; }
    if (q.type === "triomino4x4"){ $card.classList.add("rule-unique"); return; }
    const row = q.rowRuleId || "xor";
    const col = q.colRuleId || "xor";
    $card.classList.add(`rule-${row}${col}`);
  }

  function renderMatrix(q){
    const n = q.size || 3;
    $matrix.innerHTML = "";
    $matrix.style.gridTemplateColumns = `repeat(${n}, 1fr)`;

    if (q.type === "triomino4x4"){
      $matrix.style.gridTemplateColumns = `repeat(4, 1fr)`;
      const isHole = (r,c)=> q.holeCells.some(([rr,cc])=>rr===r && cc===c);
      for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
          const cell = document.createElement("div");
          cell.className = "cell" + (isHole(r,c) ? " q" : "");
          if (isHole(r,c)){
            const mark = document.createElement("div");
            mark.className = "qmark";
            mark.textContent = "?";
            cell.appendChild(mark);
          } else {
            cell.innerHTML = symbolSVG(q.grid[r][c], 54);
          }
          $matrix.appendChild(cell);
        }
      }
      return;
    }

    const holeIndex = n*n - 1;
    for (let i=0;i<n*n;i++){
      const cell = document.createElement("div");
      cell.className = "cell" + (i===holeIndex ? " q" : "");
      if (i===holeIndex){
        const mark = document.createElement("div");
        mark.className = "qmark";
        mark.textContent = "?";
        cell.appendChild(mark);
      } else {
        const r = Math.floor(i/n);
        const c = i % n;
        const safeTheme = q.theme || THEMES.logic_sq;
        cell.innerHTML = cellToSVG(q.grid[r][c], 140, safeTheme);
      }
      $matrix.appendChild(cell);
    }
  }

  function renderOptions(q){
    $opts.innerHTML = "";
    q.options.forEach((optAny, idx) => {
      const btn = document.createElement("button");
      btn.className = "opt";
      btn.type = "button";
      btn.disabled = true;
      btn.addEventListener("click", () => onPlayerPick(idx));

      const badge = document.createElement("div");
      badge.className = "badge";
      badge.textContent = LABELS[idx];

      const thumb = document.createElement("div");
      thumb.className = "thumb";

      if (q.type === "triomino4x4"){
        thumb.innerHTML = triominoOptionSVG(optAny, 64);
      } else {
        const safeTheme = q.theme || THEMES.logic_sq;
        thumb.innerHTML = cellToSVG(optAny, 64, safeTheme);
      }

      btn.appendChild(badge);
      btn.appendChild(thumb);
      $opts.appendChild(btn);
    });
  }

  function estimateDifficulty(q){
    const dClamp = (x)=>clamp(x, 0.45, 0.80);
    if(q.type === "triomino4x4") return 0.70;
    if(q.type === "matrix3x3"){
      const isNot = (q.rowRuleId==="not" || q.colRuleId==="not");
      const isXnor = (q.rowRuleId==="xnor" || q.colRuleId==="xnor");
      let d = 0.55;
      if(isNot) d += 0.10;
      if(isXnor) d += 0.06;
      return dClamp(d);
    }
    if(q.type === "relation2x2") return 0.45;
    if(q.type === "countAdd3x3") return 0.60;
    if(q.type === "shiftChain3x3") return 0.50;
    if(q.type === "mirrorXor3x3") return 0.62;
    return 0.55;
  }

  function makeBattleQuestion(){
    let q = null;
    for (let t=0;t<80;t++){
      q = pickGenerator()();
      if (q.type === "triomino4x4"){
        const uniq = new Set(q.options.map(triKey)).size;
        if (uniq >= 6 && q.ansIndex >= 0) break;
      } else {
        const uniq = new Set(q.options.map(cellKey)).size;
        const visibleCells = q.grid.flat().filter(Boolean);
        const okBoard = visibleCells.every(c => {
          const n = countOnes(c);
          return n >= 1 && n <= 8;
        });
        const onesAns = countOnes(q.answer);
        if (uniq >= 6 && okBoard && onesAns >= 1 && onesAns <= 8) break;
      }
    }
    q.theme = pickThemeForType(q.type);
    q.difficulty = estimateDifficulty(q);
    return q;
  }

  /* =========================
     CPU（人間っぽい）
     ========================= */
  function planCpuAnswerHuman({cpuRank, playerRank, difficulty, limitSec, pScore, eScore}){
    const rand = ()=>Math.random();
    const rankDelta = clamp(cpuRank - playerRank, -3, 3);
    const scoreDelta = clamp(eScore - pScore, -2, 2);

    let acc = 0.80 - 0.30 * difficulty + 0.05 * rankDelta;
    acc += 0.03 * scoreDelta;
    acc += (rand()-0.5) * 0.06;
    acc = clamp(acc, 0.18, 0.96);

    const willCorrect = rand() < acc;

    let base = 4.8 + 8.2 * difficulty - 0.85 * rankDelta;
    base *= (scoreDelta>0) ? 1.06 : (scoreDelta<0 ? 0.94 : 1.00);

    const r = rand();
    let mode = "normal";
    if(r < 0.18) mode = "fast";
    else if(r > 0.86) mode = "slow";

    let time = base;
    if(mode==="fast") time *= 0.72;
    if(mode==="slow") time *= 1.28;

    time *= willCorrect ? 0.92 : 1.10;
    if(rand() < (0.12 + 0.10*difficulty)) time += 0.7 + rand()*1.6;

    if(rand() < (0.06 + 0.06*difficulty + (scoreDelta<0 ? 0.04 : 0))){
      time = Math.max(time, limitSec - (0.4 + rand()*1.0));
      if(rand() < 0.25) return { willCorrect:false, timeSec: clamp(time, 0.8, limitSec) };
    }

    time += (rand()-0.5) * 1.1;
    time = clamp(time, 0.8, limitSec);
    return { willCorrect, timeSec: time };
  }

  function scheduleCpuAnswer(q){
    const plan = planCpuAnswerHuman({
      cpuRank, playerRank,
      difficulty: q.difficulty ?? 0.55,
      limitSec: LIMIT_SEC,
      pScore: state.pScore,
      eScore: state.eScore,
    });

    let pickIndex;
    if(plan.willCorrect){
      pickIndex = q.ansIndex;
    }else{
      const pool = [0,1,2,3,4,5].filter(i=>i!==q.ansIndex);
      pickIndex = pool[Math.floor(Math.random()*pool.length)];
    }

    state.eTimerId = setTimeout(()=>{
      state.ePick = pickIndex;
      state.eTime = plan.timeSec;
      maybeFinishSoon();
    }, plan.timeSec * 1000);
  }

  /* =========================
     ラウンド開始
     ========================= */
  function randomCpuChar(){
    const pool = CHARACTERS.filter(c => c.id !== state.playerChar.id);
    state.cpuChar = pool[Math.floor(Math.random()*pool.length)];
  }

  function startRound(){
    if(state.matchEnded) return;

    clearMidResult();
    resetPicks();

    // 「開始」押した時点で CPUキャラを一度決める（最初の開始だけ）
    if(state.round===1 && state.pScore===0 && state.eScore===0 && !state.running){
      randomCpuChar();
      updateHeader();
    }

    const q = makeBattleQuestion();
    state.q = q;

    applyRuleColor(q);
    renderMatrix(q);
    renderOptions(q);
    $debug.textContent = q.debugText || "";

    setMsg("？の部分に入る図形を選んでください。");
    setPill("回答中");
    $startBtn.disabled = true;
    $nextBtn.disabled = true;
    setActiveButton(null); // 回答中は光らせない

    setOptionsEnabled(true);
    startTimer();
    scheduleCpuAnswer(q);
  }

  /* =========================
     ボタン
     ========================= */
  $startBtn.addEventListener("click", startRound);
  $nextBtn.addEventListener("click", nextStep);

  /* =========================
     初期表示
     ========================= */
  buildCharGrid();
  state.playerChar = CHARACTERS[0];
  state.cpuChar = CHARACTERS[1];

  updateHeader();
  setPill("待機");
  setMsg("「開始」を押すと同時にスタートします。");
  $timerText.textContent = LIMIT_SEC.toFixed(1);
  setActiveButton("start"); // 最初は開始だけ光る

})();
</script>
</body>
</html>
